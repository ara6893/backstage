/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";

/** Options for requesting a refresh of entities in the catalog. */
export interface RefreshOptions {
  authorizationToken?: string;
  /** The reference to a single entity that should be refreshed */
  entityRef: string;
}

/** The parts of the format that's common to all versions/kinds of entity. */
export interface Entity {
  /** The relations that this entity has with other entities. */
  relations?: EntityRelation[];
  /** The specification data describing the entity itself. */
  spec?: Record<string, unknown>;
  /** Metadata related to the entity. */
  metadata: EntityMeta;
  /** The high level entity type being described. */
  kind: string;
  /**
   * The version of specification format for this particular entity that
   * this is written against.
   */
  apiVersion: string;
}

/** A relation of a specific type to another entity in the catalog. */
export interface EntityRelation {
  /** The entity ref of the target of this relation. */
  targetRef: string;
  /** The type of the relation. */
  type: string;
}

/** Metadata fields common to all versions/kinds of entity. */
export interface EntityMeta {
  /** A list of external hyperlinks related to the entity. */
  links?: EntityLink[];
  /**
   * A list of single-valued strings, to for example classify catalog entities in
   * various ways.
   */
  tags?: string[];
  /**
   * Key/value pairs of non-identifying auxiliary information attached to the
   * entity.
   */
  annotations?: Record<string, unknown>;
  /** Key/value pairs of identifying information attached to the entity. */
  labels?: Record<string, unknown>;
  /**
   * A short (typically relatively few words, on one line) description of the
   * entity.
   */
  description?: string;
  /**
   * A display name of the entity, to be presented in user interfaces instead
   * of the `name` property above, when available.
   *
   * This field is sometimes useful when the `name` is cumbersome or ends up
   * being perceived as overly technical. The title generally does not have
   * as stringent format requirements on it, so it may contain special
   * characters and be more explanatory. Do keep it very short though, and
   * avoid situations where a title can be confused with the name of another
   * entity, or where two entities share a title.
   *
   * Note that this is only for display purposes, and may be ignored by some
   * parts of the code. Entity references still always make use of the `name`
   * property, not the title.
   */
  title?: string;
  /** The namespace that the entity belongs to. */
  namespace?: string;
  /**
   * The name of the entity.
   *
   * Must be unique within the catalog at any given point in time, for any
   * given namespace + kind pair. This value is part of the technical
   * identifier of the entity, and as such it will appear in URLs, database
   * tables, entity references, and similar. It is subject to restrictions
   * regarding what characters are allowed.
   *
   * If you want to use a different, more human readable string with fewer
   * restrictions on it in user interfaces, see the `title` field below.
   */
  name: string;
  /**
   * An opaque string that changes for each update operation to any part of
   * the entity, including metadata.
   *
   * This field can not be set by the user at creation time, and the server
   * will reject an attempt to do so. The field will be populated in read
   * operations. The field can (optionally) be specified when performing
   * update or delete operations, and the server will then reject the
   * operation if it does not match the current stored value.
   */
  etag?: string;
  /**
   * A globally unique ID for the entity.
   *
   * This field can not be set by the user at creation time, and the server
   * will reject an attempt to do so. The field will be populated in read
   * operations. The field can (optionally) be specified when performing
   * update or delete operations, but the server is free to reject requests
   * that do so in such a way that it breaks semantics.
   */
  uid?: string;
}

/** A link to external information that is related to the entity. */
export interface EntityLink {
  /** An optional value to categorize links into specific groups */
  type?: string;
  /** An optional semantic key that represents a visual icon. */
  icon?: string;
  /** An optional descriptive title for the link. */
  title?: string;
  /** The url to the external site, document, etc. */
  url: string;
}

export interface EntityAncestryResponse {
  items: EntityAncestryResponseItemsItem[];
  rootEntityRef: string;
}

export interface EntityAncestryResponseItemsItem {
  parentEntityRefs: string[];
  /** The parts of the format that's common to all versions/kinds of entity. */
  entity: Entity;
}

export interface EntitiesBatchResponse {
  /**
   * The list of entities, in the same order as the refs in the request. Entries
   * that are null signify that no entity existed with that ref.
   */
  items: (EntitiesBatchResponseItemsItem | null)[];
}

/** The response shape for {@link EntitiesCatalog.facets}. */
export interface EntityFacetsResponse {
  /** The computed facets, one entry per facet in the request. */
  facets: Record<string, unknown>;
}

export interface PathsZ15EkiLocationsPostRequestbodyContentApplicationJsonSchema {
  presence: PostContentSchemaPresence;
  target: string;
  type: string;
}

export interface Paths1Gg6W60LocationsPostResponses200ContentApplicationJsonSchema {
  exists?: boolean;
  entities: Entity[];
  /** Entity location for a specific entity. */
  location: Location;
}

/** Entity location for a specific entity. */
export interface Location {
  target: string;
  type: string;
  id: string;
}

export interface Get200ApplicationJsonItemsItem {
  /** Entity location for a specific entity. */
  data: Location;
}

export interface Paths1B34Gt4AnalyzeLocationPostRequestbodyContentApplicationJsonSchema {
  catalogFileName: string;
  location: LocationInput;
}

export interface LocationInput {
  type: string;
  target: string;
  presence: LocationInputPresence;
}

export interface AnalyzeLocationResponse {
  generateEntities: AnalyzeLocationGenerateEntity[];
  existingEntityFiles: AnalyzeLocationExistingEntity[];
}

/**
 * This is some form of representation of what the analyzer could deduce.
 * We should probably have a chat about how this can best be conveyed to
 * the frontend. It'll probably contain a (possibly incomplete) entity, plus
 * enough info for the frontend to know what form data to show to the user
 * for overriding/completing the info.
 */
export interface AnalyzeLocationGenerateEntity {
  fields: AnalyzeLocationEntityField[];
  /** Makes all keys of an entire hierarchy optional. */
  entity: RecursivePartialEntity;
}

export interface AnalyzeLocationEntityField {
  /**
   * A text to show to the user to inform about the choices made. Like, it could say
   * "Found a CODEOWNERS file that covers this target, so we suggest leaving this
   * field empty; which would currently make it owned by X" where X is taken from the
   * codeowners file.
   */
  description: string;
  value: string | null;
  /** The outcome of the analysis for this particular field */
  state: AnalyzeLocationEntityFieldState;
  /**
   * e.g. "spec.owner"? The frontend needs to know how to "inject" the field into the
   * entity again if the user wants to change it
   */
  field: string;
}

/** Makes all keys of an entire hierarchy optional. */
export interface RecursivePartialEntity {
  /**
   * The version of specification format for this particular entity that
   * this is written against.
   */
  apiVersion?: string;
  /** The high level entity type being described. */
  kind?: string;
  /** Metadata related to the entity. */
  metadata?: EntityMeta;
  /** The specification data describing the entity itself. */
  spec?: Record<string, unknown>;
  /** The relations that this entity has with other entities. */
  relations?: EntityRelation[];
}

/**
 * If the folder pointed to already contained catalog info yaml files, they are
 * read and emitted like this so that the frontend can inform the user that it
 * located them and can make sure to register them as well if they weren't
 * already
 */
export interface AnalyzeLocationExistingEntity {
  /** The parts of the format that's common to all versions/kinds of entity. */
  entity: Entity;
  isRegistered: boolean;
  /** Holds the entity location information. */
  location: LocationSpec;
}

/** Holds the entity location information. */
export interface LocationSpec {
  presence?: LocationSpecPresence;
  target: string;
  type: string;
}

export interface PathsJp8Sy2ValidateEntityPostRequestbodyContentApplicationJsonSchema {
  location: string;
  /** The parts of the format that's common to all versions/kinds of entity. */
  entity: Entity;
}

export interface Paths1ExxmzkValidateEntityPostResponses200ContentApplicationJsonSchema {}

export interface Paths1032CnjValidateEntityPostResponses200ContentApplicationJsonSchemaAnyof0 {
  /** The serialized form of an Error. */
  errors: SerializedError;
}

/** The serialized form of an Error. */
export interface SerializedError {
  /** A custom code (not necessarily the same as an HTTP response code); may not be present */
  code?: string;
  /** A stringified stack trace; may not be present */
  stack?: string;
  /** The message of the exception that was thrown */
  message: string;
  /** The name of the exception that was thrown */
  name: string;
}

export interface Paths1Rz5QutValidateEntityPostResponses200ContentApplicationJsonSchemaAnyof1 {
  errors: SerializedError[];
}

export interface EntitiesBatchResponseItemsItem extends Entity {}

/** Known values of {@link PostContentSchemaPresence} that the service accepts. */
export enum KnownPostContentSchemaPresence {
  /** Required */
  Required = "required",
  /** Optional */
  Optional = "optional"
}

/**
 * Defines values for PostContentSchemaPresence. \
 * {@link KnownPostContentSchemaPresence} can be used interchangeably with PostContentSchemaPresence,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **required** \
 * **optional**
 */
export type PostContentSchemaPresence = string;

/** Known values of {@link LocationInputPresence} that the service accepts. */
export enum KnownLocationInputPresence {
  /** Optional */
  Optional = "optional",
  /** Required */
  Required = "required"
}

/**
 * Defines values for LocationInputPresence. \
 * {@link KnownLocationInputPresence} can be used interchangeably with LocationInputPresence,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **optional** \
 * **required**
 */
export type LocationInputPresence = string;

/** Known values of {@link AnalyzeLocationEntityFieldState} that the service accepts. */
export enum KnownAnalyzeLocationEntityFieldState {
  /** AnalysisSuggestedValue */
  AnalysisSuggestedValue = "analysisSuggestedValue",
  /** AnalysisSuggestedNoValue */
  AnalysisSuggestedNoValue = "analysisSuggestedNoValue",
  /** NeedsUserInput */
  NeedsUserInput = "needsUserInput"
}

/**
 * Defines values for AnalyzeLocationEntityFieldState. \
 * {@link KnownAnalyzeLocationEntityFieldState} can be used interchangeably with AnalyzeLocationEntityFieldState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **analysisSuggestedValue** \
 * **analysisSuggestedNoValue** \
 * **needsUserInput**
 */
export type AnalyzeLocationEntityFieldState = string;

/** Known values of {@link LocationSpecPresence} that the service accepts. */
export enum KnownLocationSpecPresence {
  /** Optional */
  Optional = "optional",
  /** Required */
  Required = "required"
}

/**
 * Defines values for LocationSpecPresence. \
 * {@link KnownLocationSpecPresence} can be used interchangeably with LocationSpecPresence,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **optional** \
 * **required**
 */
export type LocationSpecPresence = string;

/** Optional parameters. */
export interface RefreshEntityOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface GetEntitiesOptionalParams extends coreClient.OperationOptions {
  filter?: string;
  fields?: string;
  offset?: string;
  limit?: string;
  after?: string;
}

/** Contains response data for the getEntities operation. */
export type GetEntitiesResponse = Entity[];

/** Optional parameters. */
export interface GetEntityByUidOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getEntityByUid operation. */
export type GetEntityByUidResponse = Entity;

/** Optional parameters. */
export interface GetEntityByNameOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getEntityByName operation. */
export type GetEntityByNameResponse = Entity;

/** Optional parameters. */
export interface GetEntityAncestryByNameOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getEntityAncestryByName operation. */
export type GetEntityAncestryByNameResponse = EntityAncestryResponse;

/** Optional parameters. */
export interface GetEntitiesByRefsOptionalParams
  extends coreClient.OperationOptions {
  fields?: string;
}

/** Contains response data for the getEntitiesByRefs operation. */
export type GetEntitiesByRefsResponse = EntitiesBatchResponse;

/** Optional parameters. */
export interface GetEntityFacetsOptionalParams
  extends coreClient.OperationOptions {
  filter?: string;
}

/** Contains response data for the getEntityFacets operation. */
export type GetEntityFacetsResponse = EntityFacetsResponse;

/** Optional parameters. */
export interface CreateLocationOptionalParams
  extends coreClient.OperationOptions {
  dryRun?: boolean;
}

/** Contains response data for the createLocation operation. */
export type CreateLocationResponse = Paths1Gg6W60LocationsPostResponses200ContentApplicationJsonSchema;

/** Optional parameters. */
export interface GetLocationsOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getLocations operation. */
export type GetLocationsResponse = Get200ApplicationJsonItemsItem[];

/** Optional parameters. */
export interface GetLocationOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getLocation operation. */
export type GetLocationResponse = Location;

/** Optional parameters. */
export interface DeleteLocationOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface AnalyzeLocationOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the analyzeLocation operation. */
export type AnalyzeLocationOperationResponse = AnalyzeLocationResponse;

/** Optional parameters. */
export interface ValidateEntityOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the validateEntity operation. */
export type ValidateEntityResponse = Paths1ExxmzkValidateEntityPostResponses200ContentApplicationJsonSchema;

/** Optional parameters. */
export interface BackstagePluginCatalogBackendOptionalParams
  extends coreClient.ServiceClientOptions {
  /** Overrides client endpoint. */
  endpoint?: string;
}
