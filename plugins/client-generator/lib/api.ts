/* eslint-disable */
// tslint:disable
/**
 * @backstage/plugin-catalog-backend
 * The Backstage backend plugin that provides the Backstage catalog
 *
 * OpenAPI spec version: 1.6.0-next.1
 * Contact: 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

export namespace AnalyzeLocationApi {
	export type AnalyzeLocationResponse =
		| AnalyzeLocation200Response
	
	export interface AnalyzeLocation200Response {
		status: 200
		contentType: 'application/json'
		body: Api.AnalyzeLocationResponse
		headers?: undefined
	}
	
}

/**
 * AnalyzeLocationApi - fetch parameter creator
 * @export
 */
export const AnalyzeLocationApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.AnalyzeLocationRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyzeLocation(request: Api.AnalyzeLocationRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling analyzeLocation.');
			}

			let localVarPath = `/analyze-location`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * AnalyzeLocationApi - functional programming interface
 * @export
 */
export const AnalyzeLocationApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.AnalyzeLocationRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		analyzeLocation(request: Api.AnalyzeLocationRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<AnalyzeLocationApi.AnalyzeLocationResponse> {
			const localVarFetchArgs = AnalyzeLocationApiFetchParamCreator(configuration).analyzeLocation(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.AnalyzeLocationResponse,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * AnalyzeLocationApi - factory interface
 * @export
 */
export const AnalyzeLocationApiFactory: FactoryFunction<AnalyzeLocationApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new AnalyzeLocationApi(configuration, basePath, fetch);
};

/**
 * AnalyzeLocationApi - interface
 * @export
 * @interface AnalyzeLocationApi
 */
export interface AnalyzeLocationApiInterface {
	/**
	 * @param {Api.AnalyzeLocationRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	analyzeLocation(request: Api.AnalyzeLocationRequest, options?: RequestInit): Promise<AnalyzeLocationApi.AnalyzeLocationResponse>

}

/**
 * AnalyzeLocationApi - object-oriented interface
 * @export
 * @class AnalyzeLocationApi
 * @extends {BaseAPI}
 */
export class AnalyzeLocationApi extends BaseAPI implements AnalyzeLocationApiInterface {
	/**
	 * @param {Api.AnalyzeLocationRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public analyzeLocation(request: Api.AnalyzeLocationRequest, options?: RequestInit) {
		return AnalyzeLocationApiFp(this.configuration).analyzeLocation(request, options)(this.fetch, this.basePath);
	}

}
export namespace EntitiesApi {
	export interface GetEntitiesRequest {
		filter?: string
		fields?: string
		offset?: string
		limit?: string
		after?: string
	}
	
	export type GetEntitiesResponse =
		| GetEntities200Response
	
	export interface GetEntities200Response {
		status: 200
		contentType: 'application/json'
		body: Api.Entity[]
		headers?: undefined
	}
	
	export type GetEntitiesByRefsResponse =
		| GetEntitiesByRefs200Response
	
	export interface GetEntitiesByRefs200Response {
		status: 200
		contentType: 'application/json'
		body: Api.EntitiesBatchResponse
		headers?: undefined
	}
	
	export interface GetEntityAncestryByNameRequest {
		kind: string
		namespace: string
		name: string
	}
	
	export type GetEntityAncestryByNameResponse =
		| GetEntityAncestryByName200Response
	
	export interface GetEntityAncestryByName200Response {
		status: 200
		contentType: 'application/json'
		body: Api.EntityAncestryResponse
		headers?: undefined
	}
	
	export interface GetEntityByNameRequest {
		kind: string
		namespace: string
		name: string
	}
	
	export type GetEntityByNameResponse =
		| GetEntityByName200Response
	
	export interface GetEntityByName200Response {
		status: 200
		contentType: 'application/json'
		body: Api.Entity
		headers?: undefined
	}
	
	export type GetEntityByUidResponse =
		| GetEntityByUid200Response
	
	export interface GetEntityByUid200Response {
		status: 200
		contentType: 'application/json'
		body: Api.Entity
		headers?: undefined
	}
	
}

/**
 * EntitiesApi - fetch parameter creator
 * @export
 */
export const EntitiesApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {string} [filter]
		 * @param {string} [fields]
		 * @param {string} [offset]
		 * @param {string} [limit]
		 * @param {string} [after]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntities(__params: EntitiesApi.GetEntitiesRequest, options: RequestInit = {}): FetchArgs {

			let localVarPath = `/entities`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.filter !== undefined) {
				localVarQueryParameter.append('filter', String(__params.filter));
			}

			if (__params.fields !== undefined) {
				localVarQueryParameter.append('fields', String(__params.fields));
			}

			if (__params.offset !== undefined) {
				localVarQueryParameter.append('offset', String(__params.offset));
			}

			if (__params.limit !== undefined) {
				localVarQueryParameter.append('limit', String(__params.limit));
			}

			if (__params.after !== undefined) {
				localVarQueryParameter.append('after', String(__params.after));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} [fields]
		 * @param {string[]} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntitiesByRefs(fields: string | undefined, request: string[], options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling getEntitiesByRefs.');
			}

			let localVarPath = `/entities/by-refs`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (fields !== undefined) {
				localVarQueryParameter.append('fields', String(fields));
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} kind
		 * @param {string} namespace
		 * @param {string} name
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityAncestryByName(__params: EntitiesApi.GetEntityAncestryByNameRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'kind' is not null or undefined
			if (__params.kind === null || __params.kind === undefined) {
				throw new RequiredError('kind', 'Required parameter kind was null or undefined when calling getEntityAncestryByName.');
			}
			// verify required parameter 'namespace' is not null or undefined
			if (__params.namespace === null || __params.namespace === undefined) {
				throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getEntityAncestryByName.');
			}
			// verify required parameter 'name' is not null or undefined
			if (__params.name === null || __params.name === undefined) {
				throw new RequiredError('name', 'Required parameter name was null or undefined when calling getEntityAncestryByName.');
			}

			let localVarPath = `/entities/by-name/{kind}/{namespace}/{name}/ancestry`
				.replace('{kind}', encodeURIComponent(String(__params.kind)))
				.replace('{namespace}', encodeURIComponent(String(__params.namespace)))
				.replace('{name}', encodeURIComponent(String(__params.name)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} kind
		 * @param {string} namespace
		 * @param {string} name
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityByName(__params: EntitiesApi.GetEntityByNameRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'kind' is not null or undefined
			if (__params.kind === null || __params.kind === undefined) {
				throw new RequiredError('kind', 'Required parameter kind was null or undefined when calling getEntityByName.');
			}
			// verify required parameter 'namespace' is not null or undefined
			if (__params.namespace === null || __params.namespace === undefined) {
				throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getEntityByName.');
			}
			// verify required parameter 'name' is not null or undefined
			if (__params.name === null || __params.name === undefined) {
				throw new RequiredError('name', 'Required parameter name was null or undefined when calling getEntityByName.');
			}

			let localVarPath = `/entities/by-name/{kind}/{namespace}/{name}`
				.replace('{kind}', encodeURIComponent(String(__params.kind)))
				.replace('{namespace}', encodeURIComponent(String(__params.namespace)))
				.replace('{name}', encodeURIComponent(String(__params.name)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} uid
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityByUid(uid: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'uid' is not null or undefined
			if (uid === null || uid === undefined) {
				throw new RequiredError('uid', 'Required parameter uid was null or undefined when calling getEntityByUid.');
			}

			let localVarPath = `/entities/by-uid/{uid}`
				.replace('{uid}', encodeURIComponent(String(uid)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {string} [filter]
		 * @param {string} [fields]
		 * @param {string} [offset]
		 * @param {string} [limit]
		 * @param {string} [after]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntities(__params: EntitiesApi.GetEntitiesRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<EntitiesApi.GetEntitiesResponse> {
			const localVarFetchArgs = EntitiesApiFetchParamCreator(configuration).getEntities(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Entity[],
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} [fields]
		 * @param {string[]} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntitiesByRefs(fields: string | undefined, request: string[], options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<EntitiesApi.GetEntitiesByRefsResponse> {
			const localVarFetchArgs = EntitiesApiFetchParamCreator(configuration).getEntitiesByRefs(fields, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.EntitiesBatchResponse,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} kind
		 * @param {string} namespace
		 * @param {string} name
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityAncestryByName(__params: EntitiesApi.GetEntityAncestryByNameRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<EntitiesApi.GetEntityAncestryByNameResponse> {
			const localVarFetchArgs = EntitiesApiFetchParamCreator(configuration).getEntityAncestryByName(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.EntityAncestryResponse,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} kind
		 * @param {string} namespace
		 * @param {string} name
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityByName(__params: EntitiesApi.GetEntityByNameRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<EntitiesApi.GetEntityByNameResponse> {
			const localVarFetchArgs = EntitiesApiFetchParamCreator(configuration).getEntityByName(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Entity,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} uid
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityByUid(uid: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<EntitiesApi.GetEntityByUidResponse> {
			const localVarFetchArgs = EntitiesApiFetchParamCreator(configuration).getEntityByUid(uid, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Entity,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory: FactoryFunction<EntitiesApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new EntitiesApi(configuration, basePath, fetch);
};

/**
 * EntitiesApi - interface
 * @export
 * @interface EntitiesApi
 */
export interface EntitiesApiInterface {
	/**
	 * @param {string} [filter]
	 * @param {string} [fields]
	 * @param {string} [offset]
	 * @param {string} [limit]
	 * @param {string} [after]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getEntities(__params: EntitiesApi.GetEntitiesRequest, options?: RequestInit): Promise<EntitiesApi.GetEntitiesResponse>

	/**
	 * @param {string} [fields]
	 * @param {string[]} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getEntitiesByRefs(fields: string | undefined, request: string[], options?: RequestInit): Promise<EntitiesApi.GetEntitiesByRefsResponse>

	/**
	 * @param {string} kind
	 * @param {string} namespace
	 * @param {string} name
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getEntityAncestryByName(__params: EntitiesApi.GetEntityAncestryByNameRequest, options?: RequestInit): Promise<EntitiesApi.GetEntityAncestryByNameResponse>

	/**
	 * @param {string} kind
	 * @param {string} namespace
	 * @param {string} name
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getEntityByName(__params: EntitiesApi.GetEntityByNameRequest, options?: RequestInit): Promise<EntitiesApi.GetEntityByNameResponse>

	/**
	 * @param {string} uid
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getEntityByUid(uid: string, options?: RequestInit): Promise<EntitiesApi.GetEntityByUidResponse>

}

/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI implements EntitiesApiInterface {
	/**
	 * @param {string} [filter]
	 * @param {string} [fields]
	 * @param {string} [offset]
	 * @param {string} [limit]
	 * @param {string} [after]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getEntities(__params: EntitiesApi.GetEntitiesRequest, options?: RequestInit) {
		return EntitiesApiFp(this.configuration).getEntities(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} [fields]
	 * @param {string[]} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getEntitiesByRefs(fields: string | undefined, request: string[], options?: RequestInit) {
		return EntitiesApiFp(this.configuration).getEntitiesByRefs(fields, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} kind
	 * @param {string} namespace
	 * @param {string} name
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getEntityAncestryByName(__params: EntitiesApi.GetEntityAncestryByNameRequest, options?: RequestInit) {
		return EntitiesApiFp(this.configuration).getEntityAncestryByName(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} kind
	 * @param {string} namespace
	 * @param {string} name
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getEntityByName(__params: EntitiesApi.GetEntityByNameRequest, options?: RequestInit) {
		return EntitiesApiFp(this.configuration).getEntityByName(__params, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} uid
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getEntityByUid(uid: string, options?: RequestInit) {
		return EntitiesApiFp(this.configuration).getEntityByUid(uid, options)(this.fetch, this.basePath);
	}

}
export namespace EntityFacetsApi {
	export interface GetEntityFacetsRequest {
		facet: string
		filter?: string
	}
	
	export type GetEntityFacetsResponse =
		| GetEntityFacets200Response
	
	export interface GetEntityFacets200Response {
		status: 200
		contentType: 'application/json'
		body: Api.EntityFacetsResponse
		headers?: undefined
	}
	
}

/**
 * EntityFacetsApi - fetch parameter creator
 * @export
 */
export const EntityFacetsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {string} facet
		 * @param {string} [filter]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityFacets(__params: EntityFacetsApi.GetEntityFacetsRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'facet' is not null or undefined
			if (__params.facet === null || __params.facet === undefined) {
				throw new RequiredError('facet', 'Required parameter facet was null or undefined when calling getEntityFacets.');
			}

			let localVarPath = `/entity-facets`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (__params.facet !== undefined) {
				localVarQueryParameter.append('facet', String(__params.facet));
			}

			if (__params.filter !== undefined) {
				localVarQueryParameter.append('filter', String(__params.filter));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * EntityFacetsApi - functional programming interface
 * @export
 */
export const EntityFacetsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {string} facet
		 * @param {string} [filter]
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEntityFacets(__params: EntityFacetsApi.GetEntityFacetsRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<EntityFacetsApi.GetEntityFacetsResponse> {
			const localVarFetchArgs = EntityFacetsApiFetchParamCreator(configuration).getEntityFacets(__params, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.EntityFacetsResponse,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * EntityFacetsApi - factory interface
 * @export
 */
export const EntityFacetsApiFactory: FactoryFunction<EntityFacetsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new EntityFacetsApi(configuration, basePath, fetch);
};

/**
 * EntityFacetsApi - interface
 * @export
 * @interface EntityFacetsApi
 */
export interface EntityFacetsApiInterface {
	/**
	 * @param {string} facet
	 * @param {string} [filter]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getEntityFacets(__params: EntityFacetsApi.GetEntityFacetsRequest, options?: RequestInit): Promise<EntityFacetsApi.GetEntityFacetsResponse>

}

/**
 * EntityFacetsApi - object-oriented interface
 * @export
 * @class EntityFacetsApi
 * @extends {BaseAPI}
 */
export class EntityFacetsApi extends BaseAPI implements EntityFacetsApiInterface {
	/**
	 * @param {string} facet
	 * @param {string} [filter]
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getEntityFacets(__params: EntityFacetsApi.GetEntityFacetsRequest, options?: RequestInit) {
		return EntityFacetsApiFp(this.configuration).getEntityFacets(__params, options)(this.fetch, this.basePath);
	}

}
export namespace LocationsApi {
	export type CreateLocationResponse =
		| CreateLocation200Response
	
	export interface CreateLocation200Response {
		status: 200
		contentType: 'application/json'
		body: Api.CreateLocation200Response
		headers?: undefined
	}
	
	export type DeleteLocationResponse =
		| DeleteLocation204Response
	
	export interface DeleteLocation204Response {
		status: 204
		body?: undefined
		headers?: undefined
	}
	
	export type GetLocationResponse =
		| GetLocation200Response
	
	export interface GetLocation200Response {
		status: 200
		contentType: 'application/json'
		body: Api.Location
		headers?: undefined
	}
	
	export type GetLocationsResponse =
		| GetLocations200Response
	
	export interface GetLocations200Response {
		status: 200
		contentType: 'application/json'
		body: Api.GetLocations200Response[]
		headers?: undefined
	}
	
}

/**
 * LocationsApi - fetch parameter creator
 * @export
 */
export const LocationsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {boolean} [dryRun]
		 * @param {Api.CreateLocationRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createLocation(dryRun: boolean | undefined, request: Api.CreateLocationRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling createLocation.');
			}

			let localVarPath = `/locations`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			if (dryRun !== undefined) {
				localVarQueryParameter.append('dryRun', String(dryRun));
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteLocation(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteLocation.');
			}

			let localVarPath = `/locations/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'DELETE' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLocation(id: string, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'id' is not null or undefined
			if (id === null || id === undefined) {
				throw new RequiredError('id', 'Required parameter id was null or undefined when calling getLocation.');
			}

			let localVarPath = `/locations/{id}`
				.replace('{id}', encodeURIComponent(String(id)));
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLocations(options: RequestInit = {}): FetchArgs {

			let localVarPath = `/locations`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {boolean} [dryRun]
		 * @param {Api.CreateLocationRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createLocation(dryRun: boolean | undefined, request: Api.CreateLocationRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<LocationsApi.CreateLocationResponse> {
			const localVarFetchArgs = LocationsApiFetchParamCreator(configuration).createLocation(dryRun, request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.CreateLocation200Response,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteLocation(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<LocationsApi.DeleteLocationResponse> {
			const localVarFetchArgs = LocationsApiFetchParamCreator(configuration).deleteLocation(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 204) {
					return {
						status: 204,
						/* No content */
					}
				}
				throw response;
			};
		},
		/**
		 * @param {string} id
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLocation(id: string, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<LocationsApi.GetLocationResponse> {
			const localVarFetchArgs = LocationsApiFetchParamCreator(configuration).getLocation(id, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.Location,
						}
					}
					throw response;
				}
				throw response;
			};
		},
		/**
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLocations(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<LocationsApi.GetLocationsResponse> {
			const localVarFetchArgs = LocationsApiFetchParamCreator(configuration).getLocations(options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.GetLocations200Response[],
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory: FactoryFunction<LocationsApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new LocationsApi(configuration, basePath, fetch);
};

/**
 * LocationsApi - interface
 * @export
 * @interface LocationsApi
 */
export interface LocationsApiInterface {
	/**
	 * @param {boolean} [dryRun]
	 * @param {Api.CreateLocationRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	createLocation(dryRun: boolean | undefined, request: Api.CreateLocationRequest, options?: RequestInit): Promise<LocationsApi.CreateLocationResponse>

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	deleteLocation(id: string, options?: RequestInit): Promise<LocationsApi.DeleteLocationResponse>

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLocation(id: string, options?: RequestInit): Promise<LocationsApi.GetLocationResponse>

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	getLocations(options?: RequestInit): Promise<LocationsApi.GetLocationsResponse>

}

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI implements LocationsApiInterface {
	/**
	 * @param {boolean} [dryRun]
	 * @param {Api.CreateLocationRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public createLocation(dryRun: boolean | undefined, request: Api.CreateLocationRequest, options?: RequestInit) {
		return LocationsApiFp(this.configuration).createLocation(dryRun, request, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public deleteLocation(id: string, options?: RequestInit) {
		return LocationsApiFp(this.configuration).deleteLocation(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {string} id
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getLocation(id: string, options?: RequestInit) {
		return LocationsApiFp(this.configuration).getLocation(id, options)(this.fetch, this.basePath);
	}

	/**
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getLocations(options?: RequestInit) {
		return LocationsApiFp(this.configuration).getLocations(options)(this.fetch, this.basePath);
	}

}
export namespace RefreshApi {
	export type RefreshEntityResponse =
		| RefreshEntity200Response
	
	export interface RefreshEntity200Response {
		status: 200
		body?: undefined
		headers?: undefined
	}
	
}

/**
 * RefreshApi - fetch parameter creator
 * @export
 */
export const RefreshApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.RefreshOptions} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshEntity(request: Api.RefreshOptions, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling refreshEntity.');
			}

			let localVarPath = `/refresh`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * RefreshApi - functional programming interface
 * @export
 */
export const RefreshApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.RefreshOptions} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshEntity(request: Api.RefreshOptions, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<RefreshApi.RefreshEntityResponse> {
			const localVarFetchArgs = RefreshApiFetchParamCreator(configuration).refreshEntity(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					return {
						status: 200,
						/* No content */
					}
				}
				throw response;
			};
		},
	}
};

/**
 * RefreshApi - factory interface
 * @export
 */
export const RefreshApiFactory: FactoryFunction<RefreshApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new RefreshApi(configuration, basePath, fetch);
};

/**
 * RefreshApi - interface
 * @export
 * @interface RefreshApi
 */
export interface RefreshApiInterface {
	/**
	 * @param {Api.RefreshOptions} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	refreshEntity(request: Api.RefreshOptions, options?: RequestInit): Promise<RefreshApi.RefreshEntityResponse>

}

/**
 * RefreshApi - object-oriented interface
 * @export
 * @class RefreshApi
 * @extends {BaseAPI}
 */
export class RefreshApi extends BaseAPI implements RefreshApiInterface {
	/**
	 * @param {Api.RefreshOptions} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public refreshEntity(request: Api.RefreshOptions, options?: RequestInit) {
		return RefreshApiFp(this.configuration).refreshEntity(request, options)(this.fetch, this.basePath);
	}

}
export namespace ValidateEntityApi {
	export type ValidateEntityResponse =
		| ValidateEntity200Response
	
	export interface ValidateEntity200Response {
		status: 200
		contentType: 'application/json'
		body: Api.ValidateEntity200Response.ObjectValue | Api.ValidateEntity200Response.ObjectValue2
		headers?: undefined
	}
	
}

/**
 * ValidateEntityApi - fetch parameter creator
 * @export
 */
export const ValidateEntityApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * @param {Api.ValidateEntityRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validateEntity(request: Api.ValidateEntityRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling validateEntity.');
			}

			let localVarPath = `/validate-entity`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			// authentication JWT required
			// http authorization required
			if (configuration && configuration.authorization) {
				const localVarAuthorizationValue = typeof configuration.authorization === 'function'
					? configuration.authorization('JWT')
					: configuration.authorization;
				if (localVarAuthorizationValue !== null) {
					localVarHeaderParameter.set("Authorization", "Bearer " + localVarAuthorizationValue);
				}
			}
			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ValidateEntityApi - functional programming interface
 * @export
 */
export const ValidateEntityApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * @param {Api.ValidateEntityRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validateEntity(request: Api.ValidateEntityRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<ValidateEntityApi.ValidateEntityResponse> {
			const localVarFetchArgs = ValidateEntityApiFetchParamCreator(configuration).validateEntity(request, options);
			return async (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				const response = await fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options)
				const contentType = response.headers.get('Content-Type');
				const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
				
				if (response.status === 200) {
					if (mimeType === 'application/json') {
						return {
							status: 200,
							contentType: 'application/json',
							body: await response.json() as Api.ValidateEntity200Response.ObjectValue | Api.ValidateEntity200Response.ObjectValue2,
						}
					}
					throw response;
				}
				throw response;
			};
		},
	}
};

/**
 * ValidateEntityApi - factory interface
 * @export
 */
export const ValidateEntityApiFactory: FactoryFunction<ValidateEntityApiInterface> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ValidateEntityApi(configuration, basePath, fetch);
};

/**
 * ValidateEntityApi - interface
 * @export
 * @interface ValidateEntityApi
 */
export interface ValidateEntityApiInterface {
	/**
	 * @param {Api.ValidateEntityRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	validateEntity(request: Api.ValidateEntityRequest, options?: RequestInit): Promise<ValidateEntityApi.ValidateEntityResponse>

}

/**
 * ValidateEntityApi - object-oriented interface
 * @export
 * @class ValidateEntityApi
 * @extends {BaseAPI}
 */
export class ValidateEntityApi extends BaseAPI implements ValidateEntityApiInterface {
	/**
	 * @param {Api.ValidateEntityRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public validateEntity(request: Api.ValidateEntityRequest, options?: RequestInit) {
		return ValidateEntityApiFp(this.configuration).validateEntity(request, options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
