/* eslint-disable */
// tslint:disable
/**
 * @backstage/plugin-catalog-backend
 * The Backstage backend plugin that provides the Backstage catalog
 *
 * OpenAPI spec version: 1.6.0-next.1
 * Contact: 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

export namespace Api {
	export interface AnalyzeLocationEntityField {
		/**
		 * @description <p>A text to show to the user to inform about the choices made. Like, it could say
		 *  &quot;Found a CODEOWNERS file that covers this target, so we suggest leaving this
		 *  field empty; which would currently make it owned by X&quot; where X is taken from the
		 *  codeowners file.</p>
		 * @type {string}
		 * @memberof AnalyzeLocationEntityField
		 */
		description: string;
		value: string | null;
		/**
		 * @description <p>The outcome of the analysis for this particular field</p>
		 * @type {Api.AnalyzeLocationEntityField.StateEnum}
		 * @memberof AnalyzeLocationEntityField
		 */
		state: Api.AnalyzeLocationEntityField.StateEnum;
		/**
		 * @description <p>e.g. &quot;spec.owner&quot;? The frontend needs to know how to &quot;inject&quot; the field into the
		 *  entity again if the user wants to change it</p>
		 * @type {string}
		 * @memberof AnalyzeLocationEntityField
		 */
		field: string;
	}
	
	/**
	 * @export
	 * @namespace AnalyzeLocationEntityField
	 */
	export namespace AnalyzeLocationEntityField {
		/**
		 * <p>The outcome of the analysis for this particular field</p>
		 */
		export enum StateEnum {
			AnalysisSuggestedValue = 'analysisSuggestedValue',
			AnalysisSuggestedNoValue = 'analysisSuggestedNoValue',
			NeedsUserInput = 'needsUserInput'
		}
	
	}

	/**
	 * <p>If the folder pointed to already contained catalog info yaml files, they are
	 * read and emitted like this so that the frontend can inform the user that it
	 * located them and can make sure to register them as well if they weren&#39;t
	 * already</p>
	 */
	export interface AnalyzeLocationExistingEntity {
		/**
		 * @description <p>The parts of the format that&#39;s common to all versions/kinds of entity.</p>
		 * @type {Api.Entity}
		 * @memberof AnalyzeLocationExistingEntity
		 */
		entity: Api.Entity;
		isRegistered: boolean;
		/**
		 * @description <p>Holds the entity location information.</p>
		 * @type {Api.LocationSpec}
		 * @memberof AnalyzeLocationExistingEntity
		 */
		location: Api.LocationSpec;
	}

	/**
	 * <p>This is some form of representation of what the analyzer could deduce.
	 * We should probably have a chat about how this can best be conveyed to
	 * the frontend. It&#39;ll probably contain a (possibly incomplete) entity, plus
	 * enough info for the frontend to know what form data to show to the user
	 * for overriding/completing the info.</p>
	 */
	export interface AnalyzeLocationGenerateEntity {
		fields: Api.AnalyzeLocationEntityField[];
		/**
		 * @description <p>Makes all keys of an entire hierarchy optional.</p>
		 * @type {Api.RecursivePartialEntity_}
		 * @memberof AnalyzeLocationGenerateEntity
		 */
		entity: Api.RecursivePartialEntity_;
	}

	export interface AnalyzeLocationRequest {
		catalogFileName: string;
		location: Api.LocationInput;
	}

	export interface AnalyzeLocationResponse {
		generateEntities: Api.AnalyzeLocationGenerateEntity[];
		existingEntityFiles: Api.AnalyzeLocationExistingEntity[];
	}

	export interface CreateLocation200Response {
		exists?: boolean;
		entities: Api.Entity[];
		/**
		 * @description <p>Entity location for a specific entity.</p>
		 * @type {Api.Location}
		 * @memberof CreateLocation200Response
		 */
		location: Api.Location;
	}

	export interface CreateLocationRequest {
		presence: Api.CreateLocationRequest.PresenceEnum;
		target: string;
		'type': string;
	}
	
	/**
	 * @export
	 * @namespace CreateLocationRequest
	 */
	export namespace CreateLocationRequest {
		export enum PresenceEnum {
			Required = 'required',
			Optional = 'optional'
		}
	
	}

	export interface EntitiesBatchResponse {
		/**
		 * @description <p>The list of entities, in the same order as the refs in the request. Entries
		 *  that are null signify that no entity existed with that ref.</p>
		 * @type {(Api.EntitiesBatchResponse.Item | null)[]}
		 * @memberof EntitiesBatchResponse
		 */
		items: (Api.EntitiesBatchResponse.Item | null)[];
	}
	
	/**
	 * @export
	 * @namespace EntitiesBatchResponse
	 */
	export namespace EntitiesBatchResponse {
		export interface Item extends Api.Entity {
		}
	
	}

	/**
	 * <p>The parts of the format that&#39;s common to all versions/kinds of entity.</p>
	 */
	export interface Entity {
		/**
		 * @description <p>The relations that this entity has with other entities.</p>
		 * @type {Api.EntityRelation[]}
		 * @memberof Entity
		 */
		relations?: Api.EntityRelation[];
		/**
		 * @description <p>The specification data describing the entity itself.</p>
		 * @type {Api.JsonObject}
		 * @memberof Entity
		 */
		spec?: Api.JsonObject;
		/**
		 * @description <p>Metadata related to the entity.</p>
		 * @type {Api.EntityMeta}
		 * @memberof Entity
		 */
		metadata: Api.EntityMeta;
		/**
		 * @description <p>The high level entity type being described.</p>
		 * @type {string}
		 * @memberof Entity
		 */
		kind: string;
		/**
		 * @description <p>The version of specification format for this particular entity that
		 *  this is written against.</p>
		 * @type {string}
		 * @memberof Entity
		 */
		apiVersion: string;
	}

	export interface EntityAncestryResponse {
		items: Api.EntityAncestryResponse.Item[];
		rootEntityRef: string;
	}
	
	/**
	 * @export
	 * @namespace EntityAncestryResponse
	 */
	export namespace EntityAncestryResponse {
		export interface Item {
			parentEntityRefs: string[];
			/**
			 * @description <p>The parts of the format that&#39;s common to all versions/kinds of entity.</p>
			 * @type {Api.Entity}
			 * @memberof Item
			 */
			entity: Api.Entity;
		}
	
	}

	/**
	 * <p>The response shape for {@link EntitiesCatalog.facets}.</p>
	 */
	export interface EntityFacetsResponse {
		/**
		 * @description <p>The computed facets, one entry per facet in the request.</p>
		 * @type {Api.RecordStringArrayValueStringCountNumber___}
		 * @memberof EntityFacetsResponse
		 */
		facets: Api.RecordStringArrayValueStringCountNumber___;
	}

	/**
	 * <p>A link to external information that is related to the entity.</p>
	 */
	export interface EntityLink {
		/**
		 * @description <p>An optional value to categorize links into specific groups</p>
		 * @type {string}
		 * @memberof EntityLink
		 */
		'type'?: string;
		/**
		 * @description <p>An optional semantic key that represents a visual icon.</p>
		 * @type {string}
		 * @memberof EntityLink
		 */
		icon?: string;
		/**
		 * @description <p>An optional descriptive title for the link.</p>
		 * @type {string}
		 * @memberof EntityLink
		 */
		title?: string;
		/**
		 * @description <p>The url to the external site, document, etc.</p>
		 * @type {string}
		 * @memberof EntityLink
		 */
		url: string;
	}

	/**
	 * <p>Metadata fields common to all versions/kinds of entity.</p>
	 */
	export interface EntityMeta extends Api.JsonObject {
		/**
		 * @description <p>A list of external hyperlinks related to the entity.</p>
		 * @type {Api.EntityLink[]}
		 * @memberof EntityMeta
		 */
		links?: Api.EntityLink[];
		/**
		 * @description <p>A list of single-valued strings, to for example classify catalog entities in
		 *  various ways.</p>
		 * @type {string[]}
		 * @memberof EntityMeta
		 */
		tags?: string[];
		/**
		 * @description <p>Key/value pairs of non-identifying auxiliary information attached to the
		 *  entity.</p>
		 * @type {Api.RecordStringString_}
		 * @memberof EntityMeta
		 */
		annotations?: Api.RecordStringString_;
		/**
		 * @description <p>Key/value pairs of identifying information attached to the entity.</p>
		 * @type {Api.RecordStringString_}
		 * @memberof EntityMeta
		 */
		labels?: Api.RecordStringString_;
		/**
		 * @description <p>A short (typically relatively few words, on one line) description of the
		 *  entity.</p>
		 * @type {string}
		 * @memberof EntityMeta
		 */
		description?: string;
		/**
		 * @description <p>A display name of the entity, to be presented in user interfaces instead
		 *  of the <code>name</code> property above, when available.</p>
		 *  <p>This field is sometimes useful when the <code>name</code> is cumbersome or ends up
		 *  being perceived as overly technical. The title generally does not have
		 *  as stringent format requirements on it, so it may contain special
		 *  characters and be more explanatory. Do keep it very short though, and
		 *  avoid situations where a title can be confused with the name of another
		 *  entity, or where two entities share a title.</p>
		 *  <p>Note that this is only for display purposes, and may be ignored by some
		 *  parts of the code. Entity references still always make use of the <code>name</code>
		 *  property, not the title.</p>
		 * @type {string}
		 * @memberof EntityMeta
		 */
		title?: string;
		/**
		 * @description <p>The namespace that the entity belongs to.</p>
		 * @type {string}
		 * @memberof EntityMeta
		 */
		namespace?: string;
		/**
		 * @description <p>The name of the entity.</p>
		 *  <p>Must be unique within the catalog at any given point in time, for any
		 *  given namespace + kind pair. This value is part of the technical
		 *  identifier of the entity, and as such it will appear in URLs, database
		 *  tables, entity references, and similar. It is subject to restrictions
		 *  regarding what characters are allowed.</p>
		 *  <p>If you want to use a different, more human readable string with fewer
		 *  restrictions on it in user interfaces, see the <code>title</code> field below.</p>
		 * @type {string}
		 * @memberof EntityMeta
		 */
		name: string;
		/**
		 * @description <p>An opaque string that changes for each update operation to any part of
		 *  the entity, including metadata.</p>
		 *  <p>This field can not be set by the user at creation time, and the server
		 *  will reject an attempt to do so. The field will be populated in read
		 *  operations. The field can (optionally) be specified when performing
		 *  update or delete operations, and the server will then reject the
		 *  operation if it does not match the current stored value.</p>
		 * @type {string}
		 * @memberof EntityMeta
		 */
		etag?: string;
		/**
		 * @description <p>A globally unique ID for the entity.</p>
		 *  <p>This field can not be set by the user at creation time, and the server
		 *  will reject an attempt to do so. The field will be populated in read
		 *  operations. The field can (optionally) be specified when performing
		 *  update or delete operations, but the server is free to reject requests
		 *  that do so in such a way that it breaks semantics.</p>
		 * @type {string}
		 * @memberof EntityMeta
		 */
		uid?: string;
	}

	/**
	 * <p>A relation of a specific type to another entity in the catalog.</p>
	 */
	export interface EntityRelation {
		/**
		 * @description <p>The entity ref of the target of this relation.</p>
		 * @type {string}
		 * @memberof EntityRelation
		 */
		targetRef: string;
		/**
		 * @description <p>The type of the relation.</p>
		 * @type {string}
		 * @memberof EntityRelation
		 */
		'type': string;
	}

	export interface GetLocations200Response {
		/**
		 * @description <p>Entity location for a specific entity.</p>
		 * @type {Api.Location}
		 * @memberof GetLocations200Response
		 */
		data: Api.Location;
	}

	/**
	 * <p>A type representing all allowed JSON object values.</p>
	 */
	export interface JsonObject {
	}

	/**
	 * <p>Entity location for a specific entity.</p>
	 */
	export interface Location {
		target: string;
		'type': string;
		id: string;
	}

	export interface LocationInput {
		'type': string;
		target: string;
		presence: Api.LocationInput.PresenceEnum;
	}
	
	/**
	 * @export
	 * @namespace LocationInput
	 */
	export namespace LocationInput {
		export enum PresenceEnum {
			Optional = 'optional',
			Required = 'required'
		}
	
	}

	/**
	 * <p>Holds the entity location information.</p>
	 */
	export interface LocationSpec {
		presence?: Api.LocationSpec.PresenceEnum;
		target: string;
		'type': string;
	}
	
	/**
	 * @export
	 * @namespace LocationSpec
	 */
	export namespace LocationSpec {
		export enum PresenceEnum {
			Optional = 'optional',
			Required = 'required'
		}
	
	}

	/**
	 * <p>Construct a type with a set of properties K of type T</p>
	 */
	export interface RecordStringArrayValueStringCountNumber___ {
	}

	/**
	 * <p>Construct a type with a set of properties K of type T</p>
	 */
	export interface RecordStringString_ {
	}

	/**
	 * <p>Makes all keys of an entire hierarchy optional.</p>
	 */
	export interface RecursivePartialEntity_ {
		/**
		 * @description <p>The version of specification format for this particular entity that
		 *  this is written against.</p>
		 * @type {string}
		 * @memberof RecursivePartialEntity_
		 */
		apiVersion?: string;
		/**
		 * @description <p>The high level entity type being described.</p>
		 * @type {string}
		 * @memberof RecursivePartialEntity_
		 */
		kind?: string;
		/**
		 * @description <p>Metadata related to the entity.</p>
		 * @type {Api.EntityMeta}
		 * @memberof RecursivePartialEntity_
		 */
		metadata?: Api.EntityMeta;
		/**
		 * @description <p>The specification data describing the entity itself.</p>
		 * @type {Api.JsonObject}
		 * @memberof RecursivePartialEntity_
		 */
		spec?: Api.JsonObject;
		/**
		 * @description <p>The relations that this entity has with other entities.</p>
		 * @type {Api.EntityRelation[]}
		 * @memberof RecursivePartialEntity_
		 */
		relations?: Api.EntityRelation[];
	}

	/**
	 * <p>Options for requesting a refresh of entities in the catalog.</p>
	 */
	export interface RefreshOptions {
		authorizationToken?: string;
		/**
		 * @description <p>The reference to a single entity that should be refreshed</p>
		 * @type {string}
		 * @memberof RefreshOptions
		 */
		entityRef: string;
	}

	/**
	 * <p>The serialized form of an Error.</p>
	 */
	export interface SerializedError extends Api.JsonObject {
		/**
		 * @description <p>A custom code (not necessarily the same as an HTTP response code); may not be present</p>
		 * @type {string}
		 * @memberof SerializedError
		 */
		code?: string;
		/**
		 * @description <p>A stringified stack trace; may not be present</p>
		 * @type {string}
		 * @memberof SerializedError
		 */
		stack?: string;
		/**
		 * @description <p>The message of the exception that was thrown</p>
		 * @type {string}
		 * @memberof SerializedError
		 */
		message: string;
		/**
		 * @description <p>The name of the exception that was thrown</p>
		 * @type {string}
		 * @memberof SerializedError
		 */
		name: string;
	}

	export type ValidateEntity200Response = Api.ValidateEntity200Response.ObjectValue | Api.ValidateEntity200Response.ObjectValue2;
	
	/**
	 * @export
	 * @namespace ValidateEntity200Response
	 */
	export namespace ValidateEntity200Response {
		export interface ObjectValue {
			/**
			 * @description <p>The serialized form of an Error.</p>
			 * @type {Api.SerializedError}
			 * @memberof ObjectValue
			 */
			errors: Api.SerializedError;
		}
	
		export interface ObjectValue2 {
			errors: Api.SerializedError[];
		}
	
	}

	export interface ValidateEntityRequest {
		location: string;
		/**
		 * @description <p>The parts of the format that&#39;s common to all versions/kinds of entity.</p>
		 * @type {Api.Entity}
		 * @memberof ValidateEntityRequest
		 */
		entity: Api.Entity;
	}

}

